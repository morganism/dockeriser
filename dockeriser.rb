#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'

# --- Helper Functions ---

# Sanitize a string to be a valid Docker service/image name component
# (lowercase, alphanumeric, hyphen)
def sanitize_name(name)
  name.to_s.downcase.gsub(/[^a-z0-9\-]/, '-').gsub(/-+/, '-').gsub(/^-|-$/, '')
end

# --- Configuration ---
APP_FILENAME = 'app.rb'.freeze
DOCKERFILE_NAME = 'Dockerfile'.freeze
COMPOSE_FILENAME = 'docker-compose.yaml'.freeze
BASE_RUBY_IMAGE = 'ruby:3.3-slim'.freeze # Or choose another default

# --- Argument Parsing ---
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$PROGRAM_NAME} [options] <target_directory>"

  opts.on("-f", "--force", "Overwrite existing Dockerfile/docker-compose.yaml without asking") do |f|
    options[:force] = f
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!

target_dir = ARGV[0]

# --- Validation ---
unless target_dir
  warn "Error: Target directory argument is missing."
  warn "Usage: #{$PROGRAM_NAME} [options] <target_directory>"
  exit(1)
end

unless File.directory?(target_dir)
  warn "Error: '#{target_dir}' is not a valid directory."
  exit(1)
end

app_path = File.join(target_dir, APP_FILENAME)
unless File.exist?(app_path) # Checks for file or symlink to existing file
  warn "Error: Could not find '#{APP_FILENAME}' in '#{target_dir}'."
  exit(1)
end

# --- Determine Names ---
# Use the base name of the target directory for service/image name
dir_basename = File.basename(File.expand_path(target_dir))
service_name = sanitize_name(dir_basename)
service_name = 'ruby-app' if service_name.empty? # Fallback name
container_name = "#{service_name}_container"
image_name = service_name # Keep image name simple

# --- File Paths ---
dockerfile_path = File.join(target_dir, DOCKERFILE_NAME)
compose_path = File.join(target_dir, COMPOSE_FILENAME)

# --- Check for Existing Files ---
if !options[:force]
  if File.exist?(dockerfile_path)
    print "'#{DOCKERFILE_NAME}' already exists in '#{target_dir}'. Overwrite? (y/N): "
    exit unless STDIN.gets.chomp.downcase == 'y'
  end
  if File.exist?(compose_path)
    print "'#{COMPOSE_FILENAME}' already exists in '#{target_dir}'. Overwrite? (y/N): "
    exit unless STDIN.gets.chomp.downcase == 'y'
  end
end

# --- Generate Dockerfile Content ---
puts "Generating #{DOCKERFILE_NAME}..."

has_gemfile = File.exist?(File.join(target_dir, 'Gemfile'))

dockerfile_content = <<~DOCKERFILE
  # Dockerfile generated by dockerizer.rb on #{Time.now}
  # Base image with Ruby
  FROM #{BASE_RUBY_IMAGE}

  # Set working directory
  WORKDIR /app

  # Copy application files
  # Includes #{APP_FILENAME} and potentially other needed files/folders
  COPY . .

DOCKERFILE

if has_gemfile
  dockerfile_content += <<~DOCKERFILE_GEMFILE

  # Install dependencies if Gemfile exists
  # Copy Gemfile and lock file first for better layer caching
  COPY Gemfile Gemfile.lock* ./
  RUN bundle install --jobs $(nproc) --retry 3
DOCKERFILE_GEMFILE
end

dockerfile_content += <<~DOCKERFILE_CMD

  # Default command to run the application
  CMD ["ruby", "#{APP_FILENAME}"]
DOCKERFILE_CMD

# --- Generate docker-compose.yaml Content ---
puts "Generating #{COMPOSE_FILENAME}..."

compose_content = <<~COMPOSE
  # docker-compose.yaml generated by dockerizer.rb on #{Time.now}
  version: '3.8'

  services:
    #{service_name}:
      # Build the image using the Dockerfile in this directory (.)
      build: .
      image: #{image_name}:latest # Optional: Tag the image
      container_name: #{container_name}

      # Keep stdin open and allocate TTY for interactive sessions (docker-compose run)
      stdin_open: true
      tty: true

      # Mount the current host directory (.) into /app inside the container
      # Allows code changes on host to reflect inside container (for development)
      # and allows the app to read/write files from/to the host directory.
      volumes:
        - .:/app

      # Example: Uncomment to map a port if app.rb runs a web server
      # ports:
      #   - "3000:3000"

      # Example: Uncomment to add environment variables
      # environment:
      #   - RAILS_ENV=production
      #   - MY_VAR=my_value
COMPOSE

# --- Write Files ---
begin
  File.write(dockerfile_path, dockerfile_content)
  puts "Successfully wrote #{dockerfile_path}"

  File.write(compose_path, compose_content)
  puts "Successfully wrote #{compose_path}"
rescue Errno::EACCES => e
  warn "Error: Permission denied when writing files to '#{target_dir}'. #{e.message}"
  exit(1)
rescue StandardError => e
  warn "Error writing files: #{e.message}"
  exit(1)
end

# --- Output Instructions ---
puts "\n--- Docker Setup Complete for '#{target_dir}' ---"
puts "\nNavigate to the target directory:"
puts "  cd \"#{target_dir}\""
puts "\nThen use the following commands:"
puts "\n1. Build the Docker Image (if not using compose directly):"
puts "   docker build -t #{image_name} ."
puts "\n2. Run Interactively (for scripts needing input/output):"
puts "   docker-compose run --rm #{service_name}"
puts "   (This starts a temporary container, runs '#{APP_FILENAME}', then removes the container)"
puts "\n3. Run in Background (for long-running services like web servers):"
puts "   docker-compose up -d"
puts "   (Check logs with: docker-compose logs -f)"
puts "\n4. Stop Background Service:"
puts "   docker-compose down"
puts "\n-------------------------------------------------"

exit(0)
